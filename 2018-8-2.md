# C Traps笔记
1. extern关键字声明了一个对外部变量的引用，而不是对其之定义
2. static关键字将变量或函数的作用域限制在一个源文件内
3. 变量内存分配
		int i;
		char c;
		for(i = 0; i < 5; i++)
		{
			scanf("%d", &c);
			printf("%d", i);
		}		//	内存中的字节序从低到高为：c, i[0](最低字节), i[1], ...
				//	故scanf会覆盖到i的低字节导致循环终止的不确定
4. char[]与char\*
	char[]只申请了一块用于存放字符的内存，而char\*申请了一块用于存放指针值的内存，故不能
		char filename[] = "/etc/passwd";
		extern char *filename;
5. 练习4.2
		#include <stdio.h>
		main(){
			printf("%g\n", sqrt(2));
		}
	在某些系统中打印结果是：
	%g
	请问这是为什么？
    在某些C语言实现中，存在着两种不同版本的printf函数：其中一种实现了用于表示浮点格式的项，如%e,%f,%g等，而另一种却没有实现这些浮点格式。库文件中同时提供了printf函数的两种版本，这样的话，那些没有用到浮点计算的程序，就可以使用不提供浮点格式支持的版本，从而节省程序空间、减少程序大小。
    在某些系统上，编程者必须显式的通知连接器是否用到了浮点运算。而另一些系统，则是通过编译器来告诉连接器在程序中是否出现了浮点运算，以自动地作出决定。上面的程序没有进行任何浮点预算！他既没有包含math.h头文件，也没有声明sqrt函数，所以，编译器无从得知sqrt是一个浮点函数。这个程序甚至都没有传送一个浮点参数给sqrt函数。所以，编译器“自认合理”地通知连接器，该程序没有进行浮点运算。
    那sqrt函数又怎么解释呢？难道sqrt函数时从库文件中取出的这个事实，还不足以证明该程序用到了浮点运算？当然，sqrt函数是从库文件中取出的这一点没错；但是，连接器可能在从库文件中取出sqrt函数之前，就已经做出了使用何种printf函数的决定。	
